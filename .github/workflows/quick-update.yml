name: Helper
run-name: Quick Update
on:
  workflow_dispatch:
    inputs:
      edition:
        description: 'Editions'
        type: choice
        required: false
        options: [ 'All', 'Java & Bedrock', 'Bedrock & Education', 'Java', 'Bedrock', 'Education' ]
      status:
        description: 'Status'
        type: choice
        default: 'Available'
        required: true
        options: [ 'Available', 'Removed', 'Developer', 'Joke', "N/A" ]
      ar_command:
        description: '+/- commands'
        type: boolean
        default: true
        required: true
      common:
        description: 'Is common'
        type: boolean
        default: true
        required: true
      command_change:
        description: 'Command changes'
        type: string
        required: true

jobs:
  update:
    name: Update
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@main
      - name: Data
        id: data
        run: |
          function getdir() {
            for file in $1/*; do
              if [ -f $file ]; then
                file=${file:2}
                if [[ $file = *.txt ]]; then
                  full_path="$full_path $file"
                fi
              else
                getdir $file
              fi
            done
          }
          declare -l edition='${{ inputs.edition }}'
          declare -l status='${{ inputs.status }}'
          declare -l change='${{ inputs.command_change }}'
          full_path=''
          getdir .
          full_path=${full_path:1}
          edition=${edition// & /-}
          if [[ $edition = *-* ]] || [ $edition = 'all' ]; then
            edition=$edition-editions
          else
            edition=$edition-edition
          fi
          path=''
          if [ $common = true ]; then
            path='commands/entire.txt'
          fi
          cmdfile="commands/$edition/$status.txt"
          if [ $status = 'n/a' ]; then
            path="commands/where/entire.txt $path"
          elif [ $status != 'joke' -a $status != 'developer' ]; then
            path="$cmdfile commands/$edition/whole.txt $path"
            if [ $common = true ]; then
              path="commands/$status.txt $path"
            fi
          fi
          if ! [ -f $cmdfile -o $status = 'n/a' ]; then
            echo '[Error]No such file or directory.'
            exit 1
          fi
          path=`echo $path | sed 's/ $//g'`
          change=${change// /}
          change_1=${change//[A-Za-z_;\/=+-]/}
          if [ "$change_1" ]; then
            echo '[Error]Invalid syntax.'
            exit 1
          fi
          #############################
          echo "$change: $path"
          echo "path=$path" >> $GITHUB_OUTPUT
          echo "full_path=$full_path" >> $GITHUB_OUTPUT
          echo "change=$change" >> $GITHUB_OUTPUT
      - name: +/-
        if: ${{ inputs.ar_command == true && steps.data.conclusion == 'success' }}
        run: |
          path='${{ steps.data.outputs.path }}'
          full_path='${{ steps.data.outputs.full_path }}'
          change='${{ steps.data.outputs.change }};'
          i=1
          if [[ $change = *=* ]]; then
            echo '[Error]Invalid syntax.'
            exit 1
          fi
          while ((1==1)); do
            cmd=`echo $change | cut -d ';' -f $i`
            if ! [ $cmd ]; then
              break
            else
              if [[ $cmd = -* ]]; then
                mode='-'
                cmd=${cmd:1}
              else
                mode='+'
                if [[ $cmd = +* ]]; then
                  cmd=${cmd:1}
                fi
              fi
              if [[ $cmd = /* ]]; then
                cmd=${cmd:1}
              fi
              echo "=== Run ($mode$cmd) ==="
              if [[ path = */where/* ]]; then
                if [ $mode = '-' ]; then
                  path=$full_path
                fi
              fi
              #############################
              for file in $path; do
                cp $file $file-1
                if [ $mode = '+' ]; then
                  echo $cmd >> $file
                else
                  sed "s/^$cmd$//g" $file | sed '/^$/d' > $file-2
                  mv $file-2 $file
                fi
                cat $file | xargs
                if ! [ "`diff -q $file $file-1`" ]; then
                  if [[ path != */where/* ]]; then
                    echo '[Error]No difference.'
                    exit 1
                  fi
                fi
                rm $file-1
              done
              echo
              ((i++))
            fi
          done
      - name: Modify
        if: ${{ inputs.ar_command == false && steps.data.conclusion == 'success' }}
        run: |
          path='${{ steps.data.outputs.path }}'
          full_path='${{ steps.data.outputs.full_path }}'
          change='${{ steps.data.outputs.change }};'
          i=1
          if [[ $change = *+* ]] || [[ $change = *-* ]]; then
            echo '[Error]Invalid syntax.'
            exit 1
          fi
          while ((1==1)); do
            cmd=`echo $change | cut -d ';' -f $i`
            if ! [ $cmd ]; then
              break
            else
              if [[ $cmd = /* ]]; then
                cmd=${cmd:1}
              fi
              echo "=== Run ($cmd) ==="
              if [[ path = */where/* ]]; then
                path=$full_path
              fi
              #############################
              for file in $path; do
                cp $file $file-1
                from=`echo $cmd | cut -d '=' -f 1`
                to=`echo $cmd | cut -d '=' -f 2`
                if [[ $to = /* ]]; then
                  to=${to:1}
                fi
                sed "s/^$from$/$to/g" $file | sed '/^$/d' > $file-2
                mv $file-2 $file
                cat $file | xargs
                if ! [ "`diff -q $file $file-1`" ]; then
                  if [[ path != */where/* ]]; then
                    echo '[Error]No difference.'
                    exit 1
                  fi
                fi
                rm $file-1
              done
              echo
              ((i++))
            fi
          done
      - name: Sort (Modify (.))
        run: |
          function getdir() {
            for file in $1/*; do
              if [ -f $file ]; then
                file=${file:2}
                if [[ $file = *.txt ]]; then
                  echo $file
                  sort -u $file -o $file
                fi
              else
                getdir $file
              fi
            done
          }
          getdir .
      - name: Test
        run: |
          path='${{ steps.data.outputs.path }}'
          for file in $path; do
            cat $file | xargs
          done
      - name: Commit & Push
        if: ${{ false }}}
        uses: stefanzweifel/git-auto-commit-action@master
        with:
          commit_message: 'Quick update'
          branch: main
